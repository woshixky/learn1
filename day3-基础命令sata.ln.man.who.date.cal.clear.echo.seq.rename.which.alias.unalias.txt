
ll 命令			--ll命令是ls -l命令的别名（后面会讲别名的意思），以长格式列出当前目录下的内容

# ll  /etc		--以长格式列出指定目录/etc的内容

文件显示的信息：
-rw-r--r--. 1 root root    62486 8月  16 23:10 install.log
drwxr-xr-x  2 root root     4096 8月  18 03:22 jiami

1.第一位代表的意思：

	-：普通文件

	d：目录文件

	b：块设备文件(block)

	c：字符设备文件(character)

	l：符号链接文件（软连接，symbolic link file）

	p：命令管道文件（pipe）

	s：套接字文件（socket）

2.文件权限：9位，每组3位，每组为：rwx（读，写，执行）rw-为？

3.权限后面那位：文件硬链接次数

4.文件的属主（owner，文件所有者，文件拥有者）

5.文件的属组（group，文件属于哪个组）

6.文件大小（size，默认单位为字节）

7.时间戳（timestamp）：这里显示的是最近一次被修改的时间

时间戳分为三种：

	1.访问时间：access
	2.修改时间：modify，文件内容发生改变
	3.改变时间：change，元数据，文件属性
8.文件名


sata命令		--查看文件的元数据（文件本身的信息）

# stat 1	
File: `1'
	  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
	Device: 802h/2050d	Inode: 4718598     Links: 1
	Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
	Access: 2015-07-02 15:32:50.951967259 +0800
	Modify: 2015-07-02 15:32:50.951967259 +0800
	Change: 2015-07-02 15:32:50.951967259 +0800

文件元数据的简单分析：

	block  块,操作系统块是一次IO的单位，系统块默认大小为4096字节（类似windows簇）
	inode  是文件系统给文件的一个编号，类似于文件的一个门牌号码


	块大小为4096的情况，一个文件占4097个字节，那么他要占两个块


	一个优化有关的问题:
	块大好，还小好?
	块大，一次IO数据量大，IO吞吐量大，空间浪费较多
	块小，正好和块大相反


链接文件命令：
链接分为两种
1.硬链接
为一个文件设置一个目录项，而不是新建一个文件，所以硬链接是共用原始文件的i节点号（inode），每当为一个文件创建一个硬链接都会在长格式列表的第二列种增加一位数，没有硬链接的文件则显示为1。硬链接的好处，创建硬链接以后，只要inode好不为0，那么该文件就不会被删除掉。

注意：
不能对目录文件创建硬链接
不能跨文件系统创建硬链接

2.符号链接
也叫做软链接，相当于我们windows系统上的快捷方式，能让我们更快速的使用该文件，删除符号链接后不会对源文件造成影响。符号链接和硬链接的区别就是，符号链接是确确实实新建了一个文件，只是把这个文件的内容指向了我们想要的文件而已，所以符号链接拥有自己的i节点号，如果把源文件删掉了，那么我们做的软链接将会失去效果，不过如果你在之前的路径上在次创建和之前那个文件相同名称的文件，该软链接将会自动找到该文件并链接起来。

我们可以使用 ll 命令查看到一个符号链接指向的是哪一个源文件：
lrwxrwxrwx  1 root root     7 9月  28 10:02 234 -> 234.txt

ln 命令		创建链接命令，不加任何选项，直接创建硬链接文件

命令格式：
# ln [选项]  源文件  [目标文件]

例：

# ln /test/1.txt   /1		为/test目录下的1.txt文件在/根目录下创建一个名字为1的硬链接

# ln -s /test/1.txt /1		为/test目录下的1.txt文件在/根目录下创建一个名字为1的符号链接
-s选项	创建符号链接

练习：
1.使用ln命令创建一个硬链接和一个符号链接

	
	
	
man 命令		--手册，帮助文档！

命令格式：
# man ls 	--查看ls命令的帮助文档
可以在该文档中获取一个命令的所有资料，包括使用方法，命令的选项等。

man只适用于内部命令（bash自带的命令）使用
外部命令需要使用 --help
例：
# ll --help  因为ll是一个外部命令，如果要查询它的帮助文档就只能使用 --help这个选项来获得


几个简单的命令：
用户登录信息命令

	whoami		--查看当前登陆的用户名（类似$USER）
	who			--当前系统的登录信息
	w			--比who的信息更多
	users		--显示who的第一列
	uptime		--登录的时间和负载
	tty			--查看当前终端
	who am i	--查看当前终端的信息
	top			--查看（动态）当前系统负载（CPU.RAM.SWAP等）
	

date 命令	显示系统时间
# date 
2017年 02月 20日 星期一 17:14:04 CST

如果需要以指定的格式显示日期，可以使用“+”开头的字符串指定其格式，详细格式如下：
%Y : 完整年份 (0000-9999)
%m : 月份 (01-12)
%d : 日 (01-31)
%H : 小时(00-23)
%M : 分钟(00-59)
%S : 秒(00-60)
%T : 直接显示时间 (24 小时制)
%X : 相当于 %H:%M:%S
%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数

如果要显示的时间不是当前时间，而是经过运算的时间，则可以用-d选项。例如显示三年前的时间：
date "+%Y-%m-%d %H:%M:%S" -d "-3 year"

显示三个月后的时间：
# date "+%Y-%m-%d %H:%M:%S" -d "+3 month"

用 -s选项可以设置系统时间：
(修改时间的日期有很多种)
# date -s "20100809 10:10:10"
# date -s "2010-08-09 10:10:10"
# date -s "2010/08/09 10:10:10"
# date -s "8/9/2010 10:10:10"
# date -s "10:10:10 20100809"

cal 命令	用来显示公历（阳历）日历

命令格式：
cal [参数][月份][年份]

使用实例：
实例1：显示当前月份日历
# cal
      二月 2017     
日 一 二 三 四 五 六
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28

显示指定月份的日历：
# cal 9 2017
	九月 2017     
日 一 二 三 四 五 六
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30

显示2013年日历:
# cal -y 2013
                               2013                               

        一月                   二月                   三月        
日 一 二 三 四 五 六   日 一 二 三 四 五 六   日 一 二 三 四 五 六
       1  2  3  4  5                   1  2                   1  2
 6  7  8  9 10 11 12    3  4  5  6  7  8  9    3  4  5  6  7  8  9
13 14 15 16 17 18 19   10 11 12 13 14 15 16   10 11 12 13 14 15 16
20 21 22 23 24 25 26   17 18 19 20 21 22 23   17 18 19 20 21 22 23
27 28 29 30 31         24 25 26 27 28         24 25 26 27 28 29 30 31
......

显示自1月1日的天数:
# cal -j
         二月 2017         
 日  一  二  三  四  五  六
             32  33  34  35
 36  37  38  39  40  41  42
 43  44  45  46  47  48  49
 50  51  52  53  54  55  56
 57  58  59

 
 clear 命令   	清屏
 # clear 	
 可使用快捷键 “ctrl+l” 替代
 
passwd 命令 	修改密码

# passwd		--修改当前用户密码
# passwd abc	--修改abc用户的密码（注意：该格式仅能root用户使用，其它普通用户只能修改自己的密码，且必须知道之前的旧密码！）

普通用户修改密码须知：
 1.必须要求输入之前旧密码
 2.密码格式必须严谨，过于简单不予以使用
 
 

ehco命令		--打印内容到终端上
# echo 123
123
 
# echo {1..10}		--产生一个序列，中间的 . 只能有两个
1 2 3 4 5 6 7 8 9 10

# echo {10..1}
10 9 8 7 6 5 4 3 2 1 

# echo {a..z}
a b c d e f g h i j k l m .......

# echo {1..10..2}		--最后的..2代表的是在序列中间产生的步长（间隔长度,跳跃的产生序列，..2代表每隔一个数产生一个，中间形成一个跨度）
1 3 5 7 9 



seq 命令 		--也是产生一个序列

# seq 1 10
1 2 3 4 5 6 7 8 9 10

参数：

-s 			--在序列间加入分隔符
# seq  -s ":" 1 10
1:2:3:4:5:6:7:8:9:10

-w			--序列的宽度（位数）相等
# seq -w -s ":" 1 2 100		--产生一串宽度相等序列步长为2的数字，和echo的写法不同，步长写在中间
001:003:005:007:009:011:013:015:017:019:021:023:025:027:029:031:033:035:037:039:041:043:045:047:049:051:053:055:057:059:061:063:065:067:069:071:073:075:077:079:081:083:085:087:089:091:093:095:097:099

特殊符号“>”的作用：

一个“>”表示将前一个命令的输出内容重定向其他的地方
两个“>>”表示将前一个命令的输出内容追加到其他的地方

例：
# touch 123.txt
# cat 123.txt 
没有内容！
# echo "123" > 123.txt		将echo输出的结果 123 重定向到123.txt文件中
# cat 123.txt
123	有了一个123
# echo "234" >> 123.txt		将echo输出的结果 234 追加到123.txt文件中
# cat 123.txt
123
234

（重定向：重新指向一个地方或者文件，注意重定向会清空文件之前包含的所有内容）
（追加：往一个文件的最后方加入新的内容）


同时创建多个文件或者目录：

# touch aaa bbb ccc		一次创建多个文件

# touch {1..10} 	一次创建10个普通文件

# mkdir {1..10}		一次创建10个目录

# touch	{1..10..2}	

# touch {a..z}.txt		--创建的普通文件结尾为.txt
	

# touch {1..5}{a..z}


通配符：
*		--该符号表示通配符的意思（统一匹配）

# touch {1..10}.txt

# cp *.txt /test		--将目录下所有以“.txt”结尾的文件拷贝到/test目录下


rename		--批量重命名命令
# touch {a..z}.txt
# rename .txt .php *.txt  		--将目录下所有以.txt结尾的文件更换为.php结尾，注意，第一个.txt为原有的结尾，.php为要更换的结尾，*.txt则表示利用通配符选择所有以.txt的文件


练习：
1.利用“一条命令”创建三个以字母命名的目录
2.创建“a-z(24个字母)”开头，以 .html 结尾的普通文件
3.用批量重命名命令rename将所有以 .html 结尾的文件改为以 .txt 结尾




命令的别名：

which 命令			--查看一个命令的路径和别名情况
命令格式：
# which 命令

例：
# which  ls			--查看ls命令的路径和别名情况
alias ls='ls --color=auto'   	--ls命令的别名
/bin/ls				--ls命令的所在路径


alias 命令				--查看系统已有命令的的别名，为命令设置别名（相当于我们人的外号或者说小名一样）

# alias 				--查询系统当前所有拥有别名的命令
alias cp='cp -i'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'

自定义别名的方法

临时有效，例: 

# alias clear=’c’		--为“clear“命令做别名为”c“

测试:

先直接在终端上敲一个dir命令，看看显示出来的内容是不是没有颜色？
（dir命令功能和ls命令相同，也是列出当前目录下的内容）

然后我们为dir命令做一个别名在试试

# alias  dir=’dir  --color=auto’ -- 为dir命令添加一个别名，后面的 --color=auto为dir命令的选项，这里我们先不用管它

此时再在终端上直接敲dir命令，现在是不是显示的内容有颜色了？

如果我们想要取消别名的话呢？

# unalias  c		--取消clear命令的c别名

# unalias  dir		--取消dir命令的dir=‘dir --color=auto’别名 

注意：自定义的别名不能和系统已有的命令或者别名冲突，想要检测自己想要的别名是否被系统暂用可以使用以下方法检测：

比如我想为rm -rf命令做一个别名叫 drm 想要检测该别名是否被暂用

# drm 	
-bash: drm: command not found		如果系统提示这条信息，那就说明该别名是可用的，没有被系统使用



以上的做别名方法只是临时有效的，如果我们想要别名一直存在的话需要用到以下方法

永久有效：

# gedit ~/.bashrc

加入自己定义的别名：

# alias c='clear'

# alias dir='dir --color=auto'

# source ~/.bashrc					--让配置文件生效

# . ~/.bashrc				


练习题：
自己选择一个比较熟悉的命令，为该命令做一个别名



作业：

1.在根目录下分别创建一个aaa和bbb目录
2.进入刚创建的aaa目录里再创建一个ddd目录
3.在ddd目录中创建一个以自己名字拼音命名的普通文件
4.使用echo命令向新建的普通文件里面追加内容，内容格式： *.*.*.*(*代表数字或字母)
5.使用ln命令为刚创建的普通文件创建在bbb目录创建一个硬链接和一个符号链接
6.为clear命令创建一个别名，别名格式为自己名字拼音，别名中要求使用的命令要用到选项，如：ll='ls -l',并使其永久生效（注意：先检查一下别名是否被系统占用！）
7.使用命令查出自己创建的别名的路劲以及该别名属于哪个命令
8.利用“一条命令”创建三个以数字命名的目录
9.创建“1-9（数字）”开头，以 .txt 结尾的普通文件
10.用批量重命名命令rename将所有以 .txt 结尾的文件改为以 .php 结尾




















